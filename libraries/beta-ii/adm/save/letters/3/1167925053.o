#/daemon/letter.c
__Letter "Not only does my system tackle read and write... It also takes on thetopic of pulling INFO from objects and if a person will be allowedin a given room. The access.db and BuildSecure.c systems didn't eventake on these topics. Mine does :) This is why i was shifting the poweraway from BuildSecure.c and into /adm/simul_efun/security_screen.cIf you come read the Builder's port version of master(). You will seethat my system is called in valid_read() and valid_write() AFTER theaccess.db settings are all checked out. Problem with the way thatBuildSecure.c was doing it is that THAT program ran before the db waschecked, This gave the affect that the things checked for by theBuildSecure.c and returns 0 were never checked for in the DB mapping.My way checks the access mapping FIRST. If the access mapping is 0,THEN it goes through my system. The net result is that access.db hasFIRST say in what a person can access. My system will have secondarysay in the access of a file.A perfect example of what im talking about can be see by restoring theBuildSecure.bak to the BuildSecure.c position and then using a testimmortal on the /doc directory. Write access was granted to the docfiles ( and i don't want builders changing these files.... )Ironman"
__Undeleted ({"stormbringer","whit",})
