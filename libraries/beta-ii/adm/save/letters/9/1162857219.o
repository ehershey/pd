#/daemon/letter.c
__Letter "-----Original letter sent by Whit to Ironman Mon Nov  6 13:13:25 2006:-----Kinda hard question.  It all deals with memory and CPU usage.  Lets talk some theory:Lets say heartbeats are stored in a array/mapping.  Heres how it would look like heartbeats = ({ ([ \"object\":(object) \"counter\":(int), \"when_to_fire\":(int) ]) })As you can recall the actual usage of set_heartbeat() takes an integer.  The integer represents how many heartbeats will be called before the event will fire.  Then counter is what would keep tabs on each heartbeat to see if the call needed to be.  So, lets take this code snippet as the affect as to how heartbeats function:for(i = 0; i < sizeof(heartbeats); i++) {	heartbeats[i][\"counter\"]++;	if(heartbeats[i][\"counter\"] >= heartbeats[i][\"when_to_fire\"]) {		call_other(heartbeats[i][\"object\"], \"heartbeat\");		heartbeats[i][\"counter\"] = 0;	}}So, we have memory loaded for holding the object reference, a counter int, and a when_to_fire int.  Now lets look at a callout:callouts = ({ ([ \"object\":(object) \"counter\":(int), \"when_to_fire\":(int), \"function\":(string), \"args\":({}) ]) })Do due the nature of callouts having the ability to pass arguments to a custom function, your having more memory allocated because the mud needs to keep track of the function and the set of arguments.  Lets look at this script now:for(i = 0; i < sizeof(callouts); i++) {	callouts[i][\"counter\"]++;	if(callouts[i][\"counter\"] >= callouts[i][\"when_to_fire\"]) {		call_other(callouts[i][\"object\"], callouts[i][\"function\"], callouts[i][\"args\"]);		callouts -= callouts[i];	}}Now, we have spent more CPU because we had to send additional information through the loop (the arguments).  We have used more memory because we had to store what the function and its arguments were.  Also, since callouts can take an odd number, the callouts have to be made every second unlike heartbeats every 2 seconds.  Your calling the same loop every second causing the CPU to work harder.Now, lets compare the two:Since callouts are very custom, they are very nice for doing certain things that normally do not have to be repeated multiple times.  Take for instance the sky system.  When a person has a low enough flying skill and they attempt to fly, a call out is set up so that way after so many seconds through the callout the person moves.  Now this may seem senseless but why would I want to set up a heartbeat for something that someone may not even be using at the time.  Just because a person is in the sky doesnt mean they are moving so having a repeatative heartbeat would be stupid.  Even if the heartbeat is doing nothing that is one more CPU cycle that occured than should have.Heartbeats are nice for repetative tasks that should occur almost all the time.  For instance, because of the complexity of a user (healing, combat, autosave) they almost need constant updating.  A player needs to auto heal.  A player needs to have combat.  A player needs to autosave.  Now, we could do something with a callout such as, call_out(\"autosave\", 2) and call_out(\"heal\", 3) and call_out(\"combat\", 2).  Think about how much more memory and CPU we just used for 1 player.  Now multiply that by the number of players.  Thats alot.To wrap things up, the differences come to this.  Use callouts for 1 time only instances and not repetative tasks.  Save the repetative tasks to the heartbeats because of the lesser memory and CPU consumption.  Whit"
__Undeleted ({"carina","hepualahaole",})
