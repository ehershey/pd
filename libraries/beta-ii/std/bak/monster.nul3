//      /std/monster.c
//      from the Nightmare mudlib
//      inheritable code for npc's
//      created by Descartes of Borg september 1992
//      added set_unique() - seeker
#include <std.h>
#include <move.h>
#include <objects.h>
#include <daemons.h>
#include <elemental.h>
#include <rest.h>
inherit LIVING;
object tmp, exp_share;
static status heart_beat_on;
float exp_share_perc;
int level, patrol, pon, pcnt, dragon_level, unique;
string *pdirs;
int Undead;
static int speed;
static int moving;
static mapping Elements;
mapping says, emotes, speech, spells;
string body_type;
private static mixed __Die;
int swarm;
void set_exp_share(object ob, float x);
void set_swarm(int x);
varargs void die(mixed killer);
void set_unique(int x);
int test_heart();
void set_spell_chance(int x);
void set_spells(string *arr);
void set_race(string str);
void set_dragon_level(int x);
int query_dragon_level();
void set_patrol(int x, string *dirs);
void do_patrol();
string return_chat();
string return_achat();
void set_level(int x);
int query_level();
void move_around();
void set_emotes(int x, string *arr, int att);
int query_undead();
void set_undead(int x);
mixed query_aggressive();
void set_aggressive(mixed arg);
int query_swarm();
void do_swarm();
void adjust_vitals();
void adjust_stats();
void adjust_skills();

void create() {
    living::create();
    emotes = ([]);
    says = ([]);
    speech = ([]);
    spells = ([]);
    enable_commands();
    seteuid(getuid(this_object()));
    init_limb_data();
    init_stats();
    init_skills(0);
    init_living();
    set_heart_beat(heart_beat_on = 1);
    speed = 0;
    set_gender("neuter");
    Undead = 0;
    Elements = ([]);
}
void heart_beat() {
  object to = this_object();
  string pre;
  string msg;
  string lang;
  string *langs;

  living::heart_beat();
  if (!to) return;

  if (!test_heart()) {
    set_heart_beat(heart_beat_on = 0);
    return;
  }

  if (pdirs)
    do_patrol();
  if (!to) return;

  if (speed && moving >= speed)
    move_around();
  else
    moving++;

  if (swarm)
     do_swarm();
  if (!to) return;

  if (to->query_current_attacker()) {
    switch (to->query_rest_type()) {
      case SLEEP:
        to->force_me("wake");
      break;
      case SIT: case REST: case LAY:
        to->force_me("stand");
      break;
      default:
    }
    pre = "attack ";
  }
  else pre = "";

  if (to->query_rest_type() != SLEEP) {
    if (emotes[pre+"chance"] > random(100)) {
      msg = emotes[pre+"msg"][random(sizeof(emotes[pre+"msg"]))];
      message("emote", msg, environment(to), ({ to }) );
    }
    else if (says[pre+"chance"] > random(100)) {
      msg = says[pre+"msg"][random(sizeof(says[pre+"msg"]))];
      command("say "+msg);
    }
  
    if (sizeof(langs = keys(speech))) {
      lang = langs[random(sizeof(langs))];
      if (speech[lang][pre+"chance"] > random(100)) {
        msg = speech[lang][pre+"msg"][random(sizeof(speech[lang][pre+"msg"]))];
        command("speak in "+lang+" "+msg);
      }
    }
  }

}

int query_undead() { return Undead; }
void set_undead(int x) { Undead = x; }

mixed query_aggressive() { return query("aggressive"); }
void set_aggressive(mixed arg) {
  if (!( intp(arg) || stringp(arg) )) return;
  set("aggressive", arg);
}

int query_swarm() { return swarm; }

void do_swarm() {
  object to = this_object();
  object *killme;

  if (!environment(to)) return;
  if (to->query_rest_type() == SLEEP) return;

  killme = filter(all_inventory(environment(to)),
    (: ($1->is_player() && $1->query_current_attacker() &&
       member_array($1, $(to)->query_attackers()) == -1) :) );

  foreach (object pl in killme) {
    to->force_me("kill "+pl->query_name());
    to->kill_ob(pl);
    // kill command might not work if disabled, etc
  }

}


void set_exp_share(object ob, float x)
{
 exp_share = ob;
 exp_share_perc = x;
 set_exp(0);
}

// This was added to prevent reduction of mob's naturally inflated hp
void fix_vital_bonus() { return; }

void set_element_attack(string elem, int x) {
 if(member_array(elem, ELEMENTS) == -1)
   return;
 if(x > 100)
   x = 100;
 Elements[elem] = x;
}

mapping query_element_attack() {
 return Elements;
}

void add_exp(int x) {
 if (exp_share)
   exp_share->add_exp( to_int(x * 75/100)  );
 return ::add_exp(0);
}
void set_unique(int x)
{
 unique = x;
}
void set_swarm(int x)
{
 swarm = x;
}
int query_heart() { return query_heart_beat(); }
void restart_heart() { set_heart_beat(1); }
void init() {
    mixed tmp;
    ::init();
    if(!heart_beat_on) set_heart_beat(heart_beat_on = 1);
    if(this_player()->query_invis()) {
        if(wizardp(this_player())) return;
        if(random(101) < (int)this_player()->query_level()) return;
    }
    if(this_player()->query_ghost()) return;
    if(this_player()->is_player()) {
        if(tmp = query("aggressive")) {
            if(intp(tmp) && tmp > (int)this_player()->query_stats("charisma"))
              kill_ob(this_player(), 0);
            else if(stringp(tmp)) call_other(this_object(), tmp);
        }
    }
}
void set_name(string str) {
   set_living_name(str);
   ::set_name(str);
   if(query_level() < 1) set_level(1);
}
varargs void die(mixed killer) {

  if (intp(killer)) killer = this_object()->query_current_attacker();

  if (!objectp(killer)) killer = 0;

  if (functionp(__Die)) {
    if (!((int)((*__Die)(killer)))) return;
  }

  if (!this_object()) return;

  set_heart_beat(0);

  living::die(killer);

  if (stringp(__Die))
    message("other_action", __Die, environment(this_object()),
      ({ this_object() }) );
  else
    message("other_action", capitalize(query_name())+
      " drops %^RED%^dead%^RESET%^ before you.",
      environment(this_object()), ({ this_object() }));

  this_object()->remove();
}

int query_npc() { return 1; }
void set_id(string *str)
{
 if (query_property("no monster") != 1)
       str += ({ "monster" });
 ::set_id(str);
}
varargs void move_player(mixed dest, string message) {
   object prev;
   string here,going,temp1,temp2,temp3;
   prev = environment(this_object());
   here = file_name(prev);
   if (stringp(dest)) {
     if (sscanf(dest,"/%s",temp1)!=1) {
       sscanf(here,"/%s",temp1);
       going = "";
       while(sscanf(temp1,"%s/%s",temp2,temp3)==2) {
         going = going + "/"+temp2;
         temp1 = temp3;
       }
       temp1 = dest;
       if (file_size(going+"/"+temp1+".c") != -1) {
         dest = going+"/"+temp1;
       }
     }
   }
   if(move(dest) == MOVE_OK) {
      message("min", query_cap_name() + " arrives.", environment(), this_object());
      message("mout", query_cap_name() + " leaves " + message + ".", prev);
      }
}
/* Call_out taken out of move_around by Hanse 1/4/93 */
void move_around() {
   string *exits, exit;
    if(!this_object()) return;
     if (environment(this_object())->query_exits()==({})) return;
   if(environment(this_object()))
       exits = (string*)environment(this_object())->query_exits();
   else exits = 0;
 if (exits)   exit = exits[random(sizeof(exits))];
  if (exits)
 this_object()->force_me(exit);
   
   moving=0;
}
// Set_Patrol by seeker May 26 2000
void set_patrol(int x, string *dirs)
{
 
 if (!x)
   return;
 if (!dirs)
   return;
 pon = 0;     // direction currently on..
 pcnt = 0;    // game ticks waiting for move
 pdirs = dirs; // directions
 patrol = x;  // speed of patrolling
}
void do_patrol()
{
 if (pcnt < patrol)
   {
    pcnt++;
    return;
   }
 pcnt = 0;
 this_object()->force_me(pdirs[pon]);
 pon++;
 if (pon > sizeof(pdirs)-1)
  {
   pon = 0;
  }
}
void set_moving(int i) { moving = i; }
void set_speed(int i) { speed = i; }
    
string query_short()
{
 string seeker;
 int i;
 seeker = ::query_short();
 i = to_int(percent(query_hp(), query_max_hp()));
 if (i < 35)
   {
    seeker += " (dying)";
   } else
 if (i < 65)
   {
    seeker += " (bleeding)";
   } else
 if (i < 95)
   {
    seeker += " (injured)";
   }
      
 if (sizeof(query_riders())) seeker += " (ridden by "+query_riders_list()+")";

 return seeker;
}
void set_level(int x) {
  if (!x || x < 1) x = 1;
  level = x;

  if (x < 25)
    set_exp( x*x*x*53 / 16 );
  else
    set_exp(x * 2000);

  set_overall_ac(x + 9);

  adjust_stats();
  adjust_skills();
  adjust_vitals();
}

void adjust_vitals() {
  if (level < 15)
    set_max_hp( level*20 + 64);
  else
    set_max_hp( level*(level-3)*2 );

  set_max_mp(query_max_hp());
  set_max_sp(level*20);

  set_hp(query_max_hp());
  set_mp(query_max_mp());
  set_sp(query_max_sp());
}

void adjust_stats() {
  // note: eventually make stats depend on race and class
  // currently it would be slow and kludgy to do so
  string race = this_object()->query_race();
  string cl = query_class();
  string *all_stats = ({
    "strength", "dexterity", "constitution",
    "charisma", "intelligence", "wisdom",
  });
  int base;

  if (level <= 20)
    base = 10+level/2;
  else
    base = level * 110 / 100;

  foreach (string stat in all_stats)
    set_stats(stat, base + random(5) - random(5) );
}

void adjust_skills() {
  // normal skill init should be fine here
  this_object()->init_skills(0);
}

int query_level() { return level; }
// Added by Valodin, June 28, 1993
// Sets the body type to a certain race using the race daemon
void set_body_type(string str) {
  mapping monster_bod;
    int mag, max_mag;
  string *mon_limbs;
  int i, max;
  if(!str || !RACE_D->is_monster_race(str))
    str = "human";
    mag = query_mp();
    max_mag = query_max_mp();
  init_limb_data();
  monster_bod = (mapping)RACE_D->monster_body(str, query_max_hp());
  for(i = 0, max = sizeof(mon_limbs = keys(monster_bod)); i < max; i++)
    add_limb(mon_limbs[i], monster_bod[mon_limbs[i]]["limb_ref"], 
             monster_bod[mon_limbs[i]]["max_dam"], 0, 0);
  set_wielding_limbs((string *)RACE_D->query_monster_wielding_limbs(str));
  set_fingers((int)RACE_D->query_monster_fingers(str));
  body_type = str;
    set_mp(mag);
    set_max_mp(max_mag);
}
string query_body_type()
{
  return body_type;
}
void set_spell_chance(int x) {
    if(!spells) spells = ([]);
    spells["chance"] = x;
}
void set_spells(string *arr) {
    if(!spells) spells = ([]);
    spells["commands"] = arr;
}
int query_spell_chance() { 
    if(spells) return spells["chance"];
    else return 0;
}
string *query_spells() {
    if(spells) return spells["commands"];
    else return 0;
}
string get_random_spell() {
    if(!spells) return 0;
    if(sizeof(spells["commands"]) <2) return spells["commands"][0];
    else return spells["commands"][random(sizeof(spells["commands"]))];
}
// These two functions remain for backwards Nightmare 1.* and 2.* compat
void set_chats(int x, string *arr) { set_emotes(x, arr, 0); }
void set_achats(int x, string *arr) { set_emotes(x, arr, 1); }
void set_emotes(int x, string *arr, int att) {
    emotes[(att ? "attack chance" : "chance")] = x;
    emotes[(att ? "attack msg" : "msg")] = arr;
}
void set_says(int x, string *arr, int att) {
    says[(att ? "attack chance" : "chance")] = x;
    says[(att ? "attack msg" : "msg")] = arr;
}
void set_speech(int x, string lang, string *arr, int att) {
    speech[lang] = ([ (att ? "attack chance" : "chance"): x,
      (att ? "attack msg" : "msg"): arr ]);
}
string query_race() { return query("race"); }
int test_heart() {
    object env;
    object *inv;
    int i;
   if( (query_mp() < query_max_mp()) || (query_hp() < query_max_hp()) ||
      (query_sp() < query_max_sp()) ) return 1;
    if(!(env = environment(this_object()))) return 0;
    if (query_hp() < 1) return 1;
    if(query_current_attacker() || speed || patrol) return 1;
    i = sizeof(inv = all_inventory(env));
    while(i--) 
      if(interactive(inv[i]) || inv[i]->query("aggressive") || inv[i]->query_property("keepheartbeat")) return 1;
    return 0;
}
int query_heart_status() { return heart_beat_on; }
void receive_message(string cl, string msg) {
   if( this_object()->query("posessed") )
      message("info", "%^RED%^%%%^RESET%^ "+msg, this_object()->query("posessed"), 0);
   if ( function_exists("catch_tell", this_object() ) )
     this_object()->catch_tell(msg);
}
void set_languages(string *langs) {
    int i;
    
    i = sizeof(langs);
    while(i--) set_lang_prof(langs[i], 10);
}
void set(string str, mixed val) {
    ::set(str, val);
    if(str == "race") LANG_D->init_languages(this_object());
}
void set_die(mixed val) {
   if(functionp(val) && geteuid(this_object()) != geteuid(val)) return;
    __Die = val;
}
mixed query_die() { return __Die; }
void set_race(string str) { set("race", str); }
void set_dragon_level(int x) { dragon_level = x; }
int query_dragon_level() { return dragon_level; }
int is_monster() { return 1; }

mixed *local_commands() {
  return commands();
}
